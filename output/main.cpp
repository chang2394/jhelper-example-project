/**
 * code generated by JHelper
 * More info: https://github.com/AlexeyDmitriev/JHelper
 * @author chang
 */


#include <cstdio>
#include <iostream>
#include <cassert>
#include <cctype>
#include <cfloat>
#include <climits>
#include <cstring>
#include <bitset>
#include <deque>
#include <map>
#include <set>
#include <stack>
#include <queue>
#include <vector>
#include <algorithm>
#include <string>

#include <cmath>
#include <fstream>
using namespace std;

typedef pair<int, int> ii;


#define TRACE

#ifdef TRACE
template<class T, class U>
ostream& operator<<(ostream& out, const pair<T, U>& a) {out << "[" << a.first << " " << a.second << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const vector<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const set<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T>
ostream& operator<<(ostream& out, const multiset<T>& a) {out << "[ "; for (auto &it : a)out << it << " "; out << "]"; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const map<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}
template<class T, class U>
ostream& operator<<(ostream& out, const multimap<T, U>& a) {for (auto &it : a)out << it.first << " -> " << it.second << " | "; return out;}

#else
#define pr(...)
#define pra(a,n)
#define praa(a,n,m)
#endif

#define mp make_pair
#define F first
#define S second

const int oo  = numeric_limits<int>::max() / 2 - 10;

const int ND = 2e5+10;
int to[ND], head[ND], nxt[ND];
int edges = 0;

int dist[ND];
bool vis[ND];

class Jumping {
public:
	void reset(){
		for(int i = 0; i < ND; ++i)
			head[i] = -1, dist[i] = oo, vis[i] = false;
		edges = 0;
	}

	void addEdge(int x,int y){
		to[edges] = y;
		nxt[edges] = head[x];
		head[x] = edges++;
	}

	void calculate(int source){
		priority_queue<ii,vector<ii>, greater<ii> > pq;
		pq.push(mp(0,source));
		dist[source] = 0;

		while(!pq.empty()){
			int x = pq.top().S;
			int d = pq.top().F;

			pq.pop();
			if (vis[x]) continue;
			vis[x] = true;

			for(int i = head[x]; i >= 0; i = nxt[i]){
				int y = to[i];
				if (!vis[y] and dist[x]+1 < dist[y]){
					dist[y] = dist[x]+1;
					pq.push(mp(dist[y],y));
				}
			}
		}
	}

	void solve(std::istream& in, std::ostream& out) {
		int tc;
		in >> tc;

		while(tc--) {
			reset();
			int n;
			in >> n;

			for (int i = 0; i < n; ++i) {
				int jump;
				in >> jump;
				if (i - jump >= 0) addEdge(i - jump, i);
				if (i + jump < n) addEdge(i + jump, i);
			}

			calculate(n - 1);
			for (int i = 0; i < n; ++i)
				out << ((dist[i] != oo) ? dist[i] : -1) << "\n";
		}
	}
};


int main() {
	Jumping solver;
	std::ifstream in("jumping.in");
	std::ostream& out(std::cout);
	solver.solve(in, out);
	return 0;
}
